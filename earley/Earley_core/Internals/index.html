<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Internals (earley.Earley_core.Internals)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">earley</a> &#x00BB; <a href="../index.html">Earley_core</a> &#x00BB; Internals</nav><h1>Module <code>Earley_core.Internals</code></h1></header><dl><dt class="spec value" id="val-debug_lvl"><a href="#val-debug_lvl" class="anchor"></a><code><span class="keyword">val</span> debug_lvl : <span>int Stdlib.ref</span></code></dt><dd><p>Flags.</p></dd></dl><dl><dt class="spec value" id="val-warn_merge"><a href="#val-warn_merge" class="anchor"></a><code><span class="keyword">val</span> warn_merge : <span>bool Stdlib.ref</span></code></dt><dt class="spec value" id="val-log"><a href="#val-log" class="anchor"></a><code><span class="keyword">val</span> log : <span><span>(<span class="type-var">'a</span>, Stdlib.out_channel, unit)</span> Stdlib.format</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt></dl><dl><dt class="spec exception" id="exception-Error"><a href="#exception-Error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Error</span></code></dt><dd><p>Exception raised for parse error. Can be raise in the action of a grammar using <code>give_up</code></p></dd></dl><dl><dt class="spec value" id="val-idt"><a href="#val-idt" class="anchor"></a><code><span class="keyword">val</span> idt : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>identity is often used</p></dd></dl><dl><dt class="spec type" id="type-blank"><a href="#type-blank" class="anchor"></a><code><span class="keyword">type</span> blank</code><code> = <a href="../Input/index.html#type-buffer">Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Input/index.html#type-buffer">Input.buffer</a> * int</code></dt><dd><p>A blank function is just a function progressing in a buffer</p></dd></dl><dl><dt class="spec type" id="type-position"><a href="#type-position" class="anchor"></a><code><span class="keyword">type</span> position</code><code> = <a href="../Input/index.html#type-buffer">Input.buffer</a> * int</code></dt><dd><p>Positions</p></dd></dl><dl><dt class="spec type" id="type-fpos"><a href="#type-fpos" class="anchor"></a><code><span class="keyword">type</span> <span>'a fpos</span></code><code> = <a href="../Input/index.html#type-buffer">Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Input/index.html#type-buffer">Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>type of a function waiting for positions</p></dd></dl><dl><dt class="spec type" id="type-pos"><a href="#type-pos" class="anchor"></a><code><span class="keyword">type</span> <span>_ pos</span></code><code> = </code><table class="variant"><tr id="type-pos.Idt" class="anchored"><td class="def constructor"><a href="#type-pos.Idt" class="anchor"></a><code>| </code><code><span class="constructor">Idt</span> : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <a href="index.html#type-pos">pos</a></span></code></td></tr><tr id="type-pos.Simple" class="anchored"><td class="def constructor"><a href="#type-pos.Simple" class="anchor"></a><code>| </code><code><span class="constructor">Simple</span> : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pos">pos</a></span></code></td></tr><tr id="type-pos.WithPos" class="anchored"><td class="def constructor"><a href="#type-pos.WithPos" class="anchor"></a><code>| </code><code><span class="constructor">WithPos</span> : <span><span class="type-var">'a</span> <a href="index.html#type-fpos">fpos</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pos">pos</a></span></code></td></tr><tr id="type-pos.Error" class="anchored"><td class="def constructor"><a href="#type-pos.Error" class="anchor"></a><code>| </code><code><span class="constructor">Error</span> : <span><span class="type-var">'a</span> <a href="index.html#type-pos">pos</a></span></code></td></tr></table></dt><dd><p>Type for action with or without position and its combinators</p></dd></dl><dl><dt class="spec value" id="val-apply_pos"><a href="#val-apply_pos" class="anchor"></a><code><span class="keyword">val</span> apply_pos : a. <span><span class="type-var">'a</span> <a href="index.html#type-pos">pos</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-fpos">fpos</a></span></code></dt><dd><p>Common combinators, easy from their types</p></dd></dl><dl><dt class="spec type" id="type-input"><a href="#type-input" class="anchor"></a><code><span class="keyword">type</span> <span>'a input</span></code><code> = <a href="../Input/index.html#type-buffer">Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> * <a href="../Input/index.html#type-buffer">Input.buffer</a> * int</code></dt><dd><p>For terminals: get the start position and returns a value with the final position</p></dd></dl><dl><dt class="spec type" id="type-errpos"><a href="#type-errpos" class="anchor"></a><code><span class="keyword">type</span> errpos</code><code> = <span><span><span>(<a href="../Input/index.html#type-buffer">Input.buffer</a> * int)</span> option</span> Stdlib.ref</span></code></dt><dd><p>A reference to record the last error useful when a terminal calls another parsing</p></dd></dl><dl><dt class="spec type" id="type-input2"><a href="#type-input2" class="anchor"></a><code><span class="keyword">type</span> <span>'a input2</span></code><code> = <a href="index.html#type-errpos">errpos</a> <span>&#45;&gt;</span> <a href="index.html#type-blank">blank</a> <span>&#45;&gt;</span> <a href="../Input/index.html#type-buffer">Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-input">input</a></span></code></dt><dd><p>Type for Ter2 terminals: get both the position before and after blank</p></dd></dl><dl><dt class="spec type" id="type-test"><a href="#type-test" class="anchor"></a><code><span class="keyword">type</span> <span>'a test</span></code><code> = <span><span>(<span class="type-var">'a</span> * bool)</span> <a href="index.html#type-fpos">fpos</a></span></code></dt><dd><p>Type for tests: get also both position and return a boolean and a value</p></dd></dl><dl><dt class="spec type" id="type-pos2"><a href="#type-pos2" class="anchor"></a><code><span class="keyword">type</span> pos2</code><code> = </code><code>{</code><table class="record"><tr id="type-pos2.buf" class="anchored"><td class="def field"><a href="#type-pos2.buf" class="anchor"></a><code>buf : <a href="../Input/index.html#type-buffer">Input.buffer</a>;</code></td></tr><tr id="type-pos2.col" class="anchored"><td class="def field"><a href="#type-pos2.col" class="anchor"></a><code>col : int;</code></td></tr><tr id="type-pos2.buf_ab" class="anchored"><td class="def field"><a href="#type-pos2.buf_ab" class="anchor"></a><code>buf_ab : <a href="../Input/index.html#type-buffer">Input.buffer</a>;</code></td></tr><tr id="type-pos2.col_ab" class="anchored"><td class="def field"><a href="#type-pos2.col_ab" class="anchor"></a><code>col_ab : int;</code></td></tr></table><code>}</code></dt><dd><p>Position record stored in the elements of the earley table. We store the position before and after the blank</p></dd></dl><dl><dt class="spec value" id="val-eq_pos"><a href="#val-eq_pos" class="anchor"></a><code><span class="keyword">val</span> eq_pos : <a href="index.html#type-pos2">pos2</a> <span>&#45;&gt;</span> <a href="index.html#type-pos2">pos2</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Some function on pos2</p></dd></dl><dl><dt class="spec value" id="val-apply_pos_start"><a href="#val-apply_pos_start" class="anchor"></a><code><span class="keyword">val</span> apply_pos_start : <span><span class="type-var">'a</span> <a href="index.html#type-pos">pos</a></span> <span>&#45;&gt;</span> <a href="index.html#type-pos2">pos2</a> <span>&#45;&gt;</span> <a href="index.html#type-pos2">pos2</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Get the position before and after the parsed text annd apply it to the combinator</p></dd></dl><dl><dt class="spec value" id="val-apply_start"><a href="#val-apply_start" class="anchor"></a><code><span class="keyword">val</span> apply_start : <span>(<a href="../Input/index.html#type-buffer">Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Input/index.html#type-buffer">Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-pos2">pos2</a> <span>&#45;&gt;</span> <a href="index.html#type-pos2">pos2</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt></dl><dl><dt class="spec type" id="type-info"><a href="#type-info" class="anchor"></a><code><span class="keyword">type</span> info</code><code> = <span><span>(bool * <a href="../Charset/index.html#type-t">Charset.t</a>)</span> <a href="../Utils/Fixpoint/index.html#type-t">Utils.Fixpoint.t</a></span></code></dt><dd><p>Type of the information computed on a rule: the boolean tells if the grammar can parse an empty string and the charset, the first accepted characteres when the rule is used to parse something.</p></dd></dl><aside><p>THE MAIN TYPES</p></aside><dl><dt class="spec type" id="type-cref"><a href="#type-cref" class="anchor"></a><code><span class="keyword">type</span> <span>'a cref</span></code><code> = <span><span class="type-var">'a</span> <a href="../Container/Ref/index.html#type-container">Container.Ref.container</a></span></code></dt><dd><p>Use the container references, because they can be reset</p></dd></dl><dl><dt class="spec type" id="type-tref"><a href="#type-tref" class="anchor"></a><code><span class="keyword">type</span> <span>'a tref</span></code><code> = <span><span><span>(<span class="type-var">'a</span> * <a href="../Input/index.html#type-buffer">Input.buffer</a> * int)</span> option</span> <a href="index.html#type-cref">cref</a></span></code></dt><dd><p>a reference to the store the result of reading a terminal</p></dd></dl><dl><dt class="spec module" id="module-Types"><a href="#module-Types" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">rec</span> <a href="Types/index.html">Types</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A BNF grammar is a list of rules. The type parameter <code>'a</code> corresponds to the type of the semantics of the grammar. For example, parsing using a grammar of type <code>int grammar</code> will produce a value of type <code>int</code>.</p></dd></dl><dl><dt class="spec module" id="module-StackContainer"><a href="#module-StackContainer" class="anchor"></a><code><span class="keyword">and</span> <a href="StackContainer/index.html">StackContainer</a> : <a href="../Container/index.html#module-type-Param">Container.Param</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>('b, 'a) <a href="../Container/module-type-Param/index.html#type-elt">elt</a></span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="Types/index.html#type-pre_stack">Types.pre_stack</a></span></code></dt><dd><p>Use container to store a point to the rule in stack, we use recursive module for that</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="index.html#module-Types">Types</a></code></span></summary><dl><dt class="spec type" id="type-grammar"><a href="#type-grammar" class="anchor"></a><code><span class="keyword">type</span> <span>'a grammar</span></code><code> = <a href="index.html#type-info">info</a> * <span><span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> list</span></code></dt><dd><p>The type of a grammar, with its information</p></dd></dl><dl><dt class="spec type" id="type-symbol"><a href="#type-symbol" class="anchor"></a><code><span class="keyword">and</span> <span>_ symbol</span></code><code> = </code><table class="variant"><tr id="type-symbol.Term" class="anchored"><td class="def constructor"><a href="#type-symbol.Term" class="anchor"></a><code>| </code><code><span class="constructor">Term</span> : </code><code>{</code><table class="record"><tr id="type-symbol.input" class="anchored"><td class="def field"><a href="#type-symbol.input" class="anchor"></a><code>input : <span><span class="type-var">'a</span> <a href="index.html#type-input">input</a></span>;</code></td></tr><tr id="type-symbol.info" class="anchored"><td class="def field"><a href="#type-symbol.info" class="anchor"></a><code>info : <a href="index.html#type-info">info</a>;</code></td></tr><tr id="type-symbol.memo" class="anchored"><td class="def field"><a href="#type-symbol.memo" class="anchor"></a><code>memo : <span><span class="type-var">'a</span> <a href="index.html#type-tref">tref</a></span>;</code></td></tr><tr id="type-symbol.name" class="anchored"><td class="def field"><a href="#type-symbol.name" class="anchor"></a><code>name : string;</code></td></tr></table><code>}</code><code> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-symbol">symbol</a></span></code></td><td class="doc"><p>terminal symbol just read the input buffer</p></td></tr><tr id="type-symbol.Ter2" class="anchored"><td class="def constructor"><a href="#type-symbol.Ter2" class="anchor"></a><code>| </code><code><span class="constructor">Ter2</span> : </code><code>{</code><table class="record"><tr id="type-symbol.input" class="anchored"><td class="def field"><a href="#type-symbol.input" class="anchor"></a><code>input : <span><span class="type-var">'a</span> <a href="index.html#type-input2">input2</a></span>;</code></td></tr><tr id="type-symbol.info" class="anchored"><td class="def field"><a href="#type-symbol.info" class="anchor"></a><code>info : <a href="index.html#type-info">info</a>;</code></td></tr><tr id="type-symbol.memo" class="anchored"><td class="def field"><a href="#type-symbol.memo" class="anchor"></a><code>memo : <span><span class="type-var">'a</span> <a href="index.html#type-tref">tref</a></span>;</code></td></tr><tr id="type-symbol.name" class="anchored"><td class="def field"><a href="#type-symbol.name" class="anchor"></a><code>name : string;</code></td></tr></table><code>}</code><code> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-symbol">symbol</a></span></code></td><td class="doc"><p>Ter2 correspond to a recursive call to the parser. We can change the blank function for instance, or parse input as much as possible. In fact it is only in the combinators in earley.ml that we see the use Ter2 to call the parser back.</p></td></tr><tr id="type-symbol.Test" class="anchored"><td class="def constructor"><a href="#type-symbol.Test" class="anchor"></a><code>| </code><code><span class="constructor">Test</span> : </code><code>{</code><table class="record"><tr id="type-symbol.input" class="anchored"><td class="def field"><a href="#type-symbol.input" class="anchor"></a><code>input : <span><span class="type-var">'a</span> <a href="index.html#type-test">test</a></span>;</code></td></tr><tr id="type-symbol.info" class="anchored"><td class="def field"><a href="#type-symbol.info" class="anchor"></a><code>info : <a href="index.html#type-info">info</a>;</code></td></tr><tr id="type-symbol.memo" class="anchored"><td class="def field"><a href="#type-symbol.memo" class="anchor"></a><code>memo : <span><span class="type-var">'a</span> <a href="index.html#type-tref">tref</a></span>;</code></td></tr><tr id="type-symbol.name" class="anchored"><td class="def field"><a href="#type-symbol.name" class="anchor"></a><code>name : string;</code></td></tr></table><code>}</code><code> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-symbol">symbol</a></span></code></td><td class="doc"><p>Test on the input, can for instance read blanks, usefull for things like ocamldoc (but not yet used by earley-ocaml).</p></td></tr><tr id="type-symbol.NonTerm" class="anchored"><td class="def constructor"><a href="#type-symbol.NonTerm" class="anchor"></a><code>| </code><code><span class="constructor">NonTerm</span> : </code><code>{</code><table class="record"><tr id="type-symbol.rules" class="anchored"><td class="def field"><a href="#type-symbol.rules" class="anchor"></a><code><span class="keyword">mutable</span> rules : <span><span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> list</span>;</code></td></tr><tr id="type-symbol.info" class="anchored"><td class="def field"><a href="#type-symbol.info" class="anchor"></a><code><span class="keyword">mutable</span> info : <a href="index.html#type-info">info</a>;</code></td></tr><tr id="type-symbol.memo" class="anchored"><td class="def field"><a href="#type-symbol.memo" class="anchor"></a><code>memo : <span><span class="type-var">'a</span> <a href="index.html#type-ntref">ntref</a></span>;</code></td></tr><tr id="type-symbol.name" class="anchored"><td class="def field"><a href="#type-symbol.name" class="anchor"></a><code>name : string;</code></td></tr></table><code>}</code><code> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-symbol">symbol</a></span></code></td><td class="doc"><p>Non terminals trough a mutable field to define recursive rule lists</p></td></tr></table></dt><dd><p>The symbol, a more general concept that terminals</p></dd></dl><dl><dt class="spec type" id="type-ntref"><a href="#type-ntref" class="anchor"></a><code><span class="keyword">and</span> <span>'a ntref</span></code><code> = <span><span><span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> list</span> <a href="index.html#type-cref">cref</a></span></code></dt><dd><p>Type of a container ref to memoize treatment of non terminal</p></dd></dl><dl><dt class="spec type" id="type-prerule"><a href="#type-prerule" class="anchor"></a><code><span class="keyword">and</span> <span>_ prerule</span></code><code> = </code><table class="variant"><tr id="type-prerule.Empty" class="anchored"><td class="def constructor"><a href="#type-prerule.Empty" class="anchor"></a><code>| </code><code><span class="constructor">Empty</span> : <span><span class="type-var">'a</span> <a href="index.html#type-pos">pos</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-prerule">prerule</a></span></code></td><td class="doc"><p>Empty rule.</p></td></tr><tr id="type-prerule.Next" class="anchored"><td class="def constructor"><a href="#type-prerule.Next" class="anchor"></a><code>| </code><code><span class="constructor">Next</span> : <a href="index.html#type-info">info</a> * <span><span class="type-var">'a</span> <a href="index.html#type-symbol">symbol</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-next">next</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-prerule">prerule</a></span></code></td><td class="doc"><p>Sequence of a symbol and a rule, with a possible name for debugging, the information on the rule, the symbol to read, an action and the rest of the rule</p></td></tr><tr id="type-prerule.Dep" class="anchored"><td class="def constructor"><a href="#type-prerule.Dep" class="anchor"></a><code>| </code><code><span class="constructor">Dep</span> : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-rule">rule</a></span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="index.html#type-prerule">prerule</a></span></code></td><td class="doc"><p>Dependant rule, gives a lot of power! but costly! use only when no other solution is possible</p></td></tr></table></dt><dd><p>BNF rule.</p></dd></dl><dl><dt class="spec type" id="type-next"><a href="#type-next" class="anchor"></a><code><span class="keyword">and</span> <span>('a, 'c) next</span></code><code> = </code><table class="variant"><tr id="type-next.Arg" class="anchored"><td class="def constructor"><a href="#type-next.Arg" class="anchor"></a><code>| </code><code><span class="constructor">Arg</span> : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-next">next</a></span></code></td></tr><tr id="type-next.Pos" class="anchored"><td class="def constructor"><a href="#type-next.Pos" class="anchor"></a><code>| </code><code><span class="constructor">Pos</span> : <span><span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <a href="index.html#type-fpos">fpos</a></span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-next">next</a></span></code></td></tr><tr id="type-next.Ign" class="anchored"><td class="def constructor"><a href="#type-next.Ign" class="anchor"></a><code>| </code><code><span class="constructor">Ign</span> : <span><span class="type-var">'c</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-next">next</a></span></code></td></tr></table></dt><dt class="spec type" id="type-rule"><a href="#type-rule" class="anchor"></a><code><span class="keyword">and</span> <span>'a rule</span></code><code> = </code><code>{</code><table class="record"><tr id="type-rule.rule" class="anchored"><td class="def field"><a href="#type-rule.rule" class="anchor"></a><code>rule : <span><span class="type-var">'a</span> <a href="index.html#type-prerule">prerule</a></span>;</code></td></tr><tr id="type-rule.ptr" class="anchored"><td class="def field"><a href="#type-rule.ptr" class="anchor"></a><code>ptr : <span><span class="type-var">'a</span> <a href="StackContainer/index.html#type-container">StackContainer.container</a></span>;</code></td></tr><tr id="type-rule.adr" class="anchored"><td class="def field"><a href="#type-rule.adr" class="anchor"></a><code>adr : int;</code></td></tr></table><code>}</code></dt><dd><p>Each rule holds a container to associate data to the rule in O(1). see below the description of the type ('a,'b) pre_stack</p></dd></dl><dl><dt class="spec type" id="type-final"><a href="#type-final" class="anchor"></a><code><span class="keyword">type</span> <span>_ final</span></code><code> = </code><table class="variant"><tr id="type-final.D" class="anchored"><td class="def constructor"><a href="#type-final.D" class="anchor"></a><code>| </code><code><span class="constructor">D</span> : </code><code>{</code><table class="record"><tr id="type-final.start" class="anchored"><td class="def field"><a href="#type-final.start" class="anchor"></a><code>start : <a href="index.html#type-pos2">pos2</a>;</code></td><td class="doc"><p>position in buffer, before and after blank</p></td></tr><tr id="type-final.stack" class="anchored"><td class="def field"><a href="#type-final.stack" class="anchor"></a><code>stack : <span><span>(<span class="type-var">'c</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-stack">stack</a></span>;</code></td><td class="doc"><p>tree of stack representing what should be done after reading the <code>rest</code> of the rule</p></td></tr><tr id="type-final.acts" class="anchored"><td class="def field"><a href="#type-final.acts" class="anchor"></a><code>acts : <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>;</code></td><td class="doc"><p>action to produce the final 'c.</p></td></tr><tr id="type-final.rest" class="anchored"><td class="def field"><a href="#type-final.rest" class="anchor"></a><code>rest : <span><span class="type-var">'b</span> <a href="index.html#type-rule">rule</a></span>;</code></td><td class="doc"><p>remaining to parse, will produce 'b</p></td></tr><tr id="type-final.full" class="anchored"><td class="def field"><a href="#type-final.full" class="anchor"></a><code>full : <span><span class="type-var">'c</span> <a href="index.html#type-rule">rule</a></span>;</code></td><td class="doc"><p>full rule. rest is a suffix of full.</p></td></tr></table><code>}</code><code> <span>&#45;&gt;</span> <span><span class="type-var">'r</span> <a href="index.html#type-final">final</a></span></code></td></tr></table></dt><dd><p>Type of an active element of the earley table. In a description of earley, each table element is <code>(start, end, done * rest)</code> meaning we parsed the string from <code>start</code> to <code>end</code> with the rule <code>done</code> and it remains to parse <code>rest</code>. The <code>*</code> therefore denotes the current position. Earley is basically a dynamic algorithm producing all possible elements.</p><p>We depart from this representation in two ways:</p><ul><li>we do not represent <code>done</code>, we keep the whole whole rule: <code>full = done rest</code></li></ul><ul><li>we never keep <code>end</code>. It is only used when we finish parsing of a rule and we have an element <code>(start, end, done * Empty)</code> then, we look for other elements of the form <code>(start', end', done' * rest')</code> where <code>end' = start</code>, <code>rest' = nonterm' rest''</code> and <code>nonterm'</code> is a non terminal containing the <code>done</code> rule. We represent this situation by a stack in the element <code>(start, end, done * Empty)</code>, which is maintained to lists all the elements satisfying the above property (no more, no less, each element only once)</li></ul><p>The type <code>'a final</code> represent an element of the earley table where <code>end</code> is the current position in the string being parsed.</p></dd></dl><dl><dt class="spec type" id="type-element"><a href="#type-element" class="anchor"></a><code><span class="keyword">and</span> <span>(_, _) element</span></code><code> = </code><table class="variant"><tr id="type-element.B" class="anchored"><td class="def constructor"><a href="#type-element.B" class="anchor"></a><code>| </code><code><span class="constructor">B</span> : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <a href="index.html#type-pos">pos</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-element">element</a></span></code></td><td class="doc"><p>End of the stack, with an action to produce the final parser value</p></td></tr><tr id="type-element.C" class="anchored"><td class="def constructor"><a href="#type-element.C" class="anchor"></a><code>| </code><code><span class="constructor">C</span> : </code><code>{</code><table class="record"><tr id="type-element.start" class="anchored"><td class="def field"><a href="#type-element.start" class="anchor"></a><code>start : <a href="index.html#type-pos2">pos2</a>;</code></td></tr><tr id="type-element.stack" class="anchored"><td class="def field"><a href="#type-element.stack" class="anchor"></a><code>stack : <span><span>(<span class="type-var">'c</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-stack">stack</a></span>;</code></td></tr><tr id="type-element.acts" class="anchored"><td class="def field"><a href="#type-element.acts" class="anchor"></a><code>acts : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <a href="index.html#type-pos">pos</a></span>;</code></td><td class="doc"><p>Here we wait <code>x:'a</code> from parents</p></td></tr><tr id="type-element.rest" class="anchored"><td class="def field"><a href="#type-element.rest" class="anchor"></a><code>rest : <span><span class="type-var">'b</span> <a href="index.html#type-rule">rule</a></span>;</code></td></tr><tr id="type-element.full" class="anchored"><td class="def field"><a href="#type-element.full" class="anchor"></a><code>full : <span><span class="type-var">'c</span> <a href="index.html#type-rule">rule</a></span>;</code></td></tr></table><code>}</code><code> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-element">element</a></span></code></td><td class="doc"><p>Cons cell of the stack with a record similar to D's</p></td></tr></table></dt><dd><p>Type of the element that appears in stacks. Note: all other elements no reachable from stacks will be collected by the GC, which is what we want to release memory.</p><p>The type is similar to the previous: <code>('a, 'r) element</code>, means that from a value of type 'a, comming from our parent in the stack, we could produce a value of type <code>'r</code> using <code>rest</code>.</p><p>The action needs to be prametrised by the future position which is unknown.</p></dd></dl><dl><dt class="spec type" id="type-stack"><a href="#type-stack" class="anchor"></a><code><span class="keyword">and</span> <span>('a, 'b) stack</span></code><code> = <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-element">element</a></span> list</span> Stdlib.ref</span></code></dt><dd><p>Stack themselves are an acyclic graph of elements (sharing is important to be preserved). We need a reference for the stack construction.</p></dd></dl><aside><p>For the construction of the stack, all elements of the same list ref of type ('a,'b) stack have the same en position <code>end'</code>. And all elements that points to this stack have their begin position <code>start = end'</code>. Moreover, all elements with the same <code>full</code> and <code>start</code> must point to the same stack. Recall that <code>end</code> is not represented in elements.</p><p>We call the position <code>end'</code> associated to a stack (as said the <code>start</code> of the element that point to this stack, the &quot;stack position&quot;. An important point: new stack elements are constructed when the stack position is the current position.</p><p>Moreover, when we add a point from an element <code>(start, end, rest, full)</code> to a stack (which is therefore at position <code>start</code>, we have <code>start = end</code> and <code>rest = full</code>. The rule has not parsed anything! This is the &quot;prediction&quot; phase of earley.</p><p>To do this construction, we use the record below with a hook that we run on all elements added to that stack. This record is only used with stack whose position are the current position: all these records will become inaccessible when we advance in parsing.</p><p>Morevoer, a direct pointer (thanks to the Container module) is kept from the <code>full</code> rule of all elements that point to these stack and that have the current position as <code>end</code>. This is the role of the functor call below.</p></aside><dl><dt class="spec type" id="type-pre_stack"><a href="#type-pre_stack" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) pre_stack</span></code><code> = </code><code>{</code><table class="record"><tr id="type-pre_stack.stack" class="anchored"><td class="def field"><a href="#type-pre_stack.stack" class="anchor"></a><code>stack : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-stack">stack</a></span>;</code></td></tr><tr id="type-pre_stack.hooks" class="anchored"><td class="def field"><a href="#type-pre_stack.hooks" class="anchor"></a><code><span class="keyword">mutable</span> hooks : <span><span>(<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-element">element</a></span> <span>&#45;&gt;</span> unit)</span> list</span>;</code></td></tr></table><code>}</code></dt><dd><p>stack in construction ... they have a hook, to run on elements added to the stack later !</p></dd></dl></details></div></div></div><aside><p>Recall the INVARIANTS:</p><p>1° Consider two C elements (or two D elements) of a stack. If their have the same start and full is means we can to the same after a complete parsing of the rule.</p><p>Then, the two elements MUST HAVE PHYSICALLY EQUAL stack</p><p>2° For D nodes, we keep only one for each (start, rest, full) triple with a merge warning when a node only differs by its actions (compared looking inside closure).</p><p>So D nodes with the same (start, rest, full) triple always have equal action. This propagates to each stack (C node with the same (start, rest, full) in the same stack have phisically equal actions.</p></aside><dl><dt class="spec value" id="val-count_rule"><a href="#val-count_rule" class="anchor"></a><code><span class="keyword">val</span> count_rule : <span>int Stdlib.ref</span></code></dt><dd><p>Counter defined outside <code>mkrule</code> due to value restriction.</p></dd></dl><dl><dt class="spec value" id="val-mkrule"><a href="#val-mkrule" class="anchor"></a><code><span class="keyword">val</span> mkrule : a. <span><span class="type-var">'a</span> <a href="index.html#type-prerule">prerule</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span></code></dt><dd><p>A function to build rule from pre_rule</p></dd></dl><dl><dt class="spec value" id="val-eq_rule"><a href="#val-eq_rule" class="anchor"></a><code><span class="keyword">val</span> eq_rule : a b. <span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Container/index.html#type-eq">Container.eq</a></span></code></dt><dd><p>Rule equlity</p></dd></dl><dl><dt class="spec value" id="val-eq_C"><a href="#val-eq_C" class="anchor"></a><code><span class="keyword">val</span> eq_C : a b. <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-element">element</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-element">element</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Equality for stack element: as we keep the invariant, we only need physical equality. You may uncomment the code below to check this.</p></dd></dl><dl><dt class="spec value" id="val-eq_D"><a href="#val-eq_D" class="anchor"></a><code><span class="keyword">val</span> eq_D : <span><span class="type-var">'a</span> <a href="index.html#type-final">final</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-final">final</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Equality on a final needs to do a comparison as it is used to test if a new element is already present.</p></dd></dl><dl><dt class="spec value" id="val-idtEmpty"><a href="#val-idtEmpty" class="anchor"></a><code><span class="keyword">val</span> idtEmpty : a. unit <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <a href="index.html#type-rule">rule</a></span></code></dt><dd><p>Some rules/grammar contruction that we need already here</p></dd></dl><dl><dt class="spec value" id="val-symbol_name"><a href="#val-symbol_name" class="anchor"></a><code><span class="keyword">val</span> symbol_name : a. <span><span class="type-var">'a</span> <a href="index.html#type-symbol">symbol</a></span> <span>&#45;&gt;</span> string</code></dt><dd><p>Handling of symbol, rule and grammar names</p></dd></dl><dl><dt class="spec value" id="val-rule_name"><a href="#val-rule_name" class="anchor"></a><code><span class="keyword">val</span> rule_name : a. <span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-grammar_name"><a href="#val-grammar_name" class="anchor"></a><code><span class="keyword">val</span> grammar_name : a. <span>?&#8288;delim:bool</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></span> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-grammar_delim_name"><a href="#val-grammar_delim_name" class="anchor"></a><code><span class="keyword">val</span> grammar_delim_name : a. <span><span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></span> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-keep_all_names"><a href="#val-keep_all_names" class="anchor"></a><code><span class="keyword">val</span> keep_all_names : <span>bool Stdlib.ref</span></code></dt><dt class="spec value" id="val-grammar_to_rule"><a href="#val-grammar_to_rule" class="anchor"></a><code><span class="keyword">val</span> grammar_to_rule : a. <span>?&#8288;name:string</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span></code></dt><dd><p>Converting a grammar to a rule</p></dd></dl><dl><dt class="spec value" id="val-force"><a href="#val-force" class="anchor"></a><code><span class="keyword">val</span> force : <span><span class="type-var">'a</span> <a href="../Utils/Fixpoint/index.html#type-t">Utils.Fixpoint.t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Basic constants/functions for rule information</p></dd></dl><dl><dt class="spec value" id="val-iempty"><a href="#val-iempty" class="anchor"></a><code><span class="keyword">val</span> iempty : <span><span>(bool * <a href="../Charset/index.html#type-charset">Charset.charset</a>)</span> <a href="../Utils/Fixpoint/index.html#type-t">Utils.Fixpoint.t</a></span></code></dt><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">val</span> any : <span><span>(bool * <a href="../Charset/index.html#type-charset">Charset.charset</a>)</span> <a href="../Utils/Fixpoint/index.html#type-t">Utils.Fixpoint.t</a></span></code></dt><dt class="spec value" id="val-rule_info"><a href="#val-rule_info" class="anchor"></a><code><span class="keyword">val</span> rule_info : a. <span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> <a href="index.html#type-info">info</a></code></dt><dd><p>managment of info = accept empty + charset accepted as first char</p></dd></dl><dl><dt class="spec value" id="val-symbol_info"><a href="#val-symbol_info" class="anchor"></a><code><span class="keyword">val</span> symbol_info : a. <span><span class="type-var">'a</span> <a href="index.html#type-symbol">symbol</a></span> <span>&#45;&gt;</span> <a href="index.html#type-info">info</a></code></dt><dt class="spec value" id="val-compose_info"><a href="#val-compose_info" class="anchor"></a><code><span class="keyword">val</span> compose_info : <span><span class="type-var">'a</span> <a href="index.html#type-symbol">symbol</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> <a href="index.html#type-info">info</a></code></dt><dt class="spec value" id="val-grammar_info"><a href="#val-grammar_info" class="anchor"></a><code><span class="keyword">val</span> grammar_info : a. <span><span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> list</span> <span>&#45;&gt;</span> <a href="index.html#type-info">info</a></code></dt><dt class="spec value" id="val-print_rule"><a href="#val-print_rule" class="anchor"></a><code><span class="keyword">val</span> print_rule : a b. <span>?&#8288;rest:<span><span class="type-var">'b</span> <a href="index.html#type-rule">rule</a></span></span> <span>&#45;&gt;</span> Stdlib.out_channel <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Printing</p></dd></dl><dl><dt class="spec value" id="val-print_pos"><a href="#val-print_pos" class="anchor"></a><code><span class="keyword">val</span> print_pos : Stdlib.out_channel <span>&#45;&gt;</span> <a href="index.html#type-pos2">pos2</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-print_final"><a href="#val-print_final" class="anchor"></a><code><span class="keyword">val</span> print_final : bool <span>&#45;&gt;</span> Stdlib.out_channel <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-final">final</a></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-print_final_no_pos"><a href="#val-print_final_no_pos" class="anchor"></a><code><span class="keyword">val</span> print_final_no_pos : Stdlib.out_channel <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-final">final</a></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-print_final"><a href="#val-print_final" class="anchor"></a><code><span class="keyword">val</span> print_final : Stdlib.out_channel <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-final">final</a></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-print_element"><a href="#val-print_element" class="anchor"></a><code><span class="keyword">val</span> print_element : a b. Stdlib.out_channel <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-element">element</a></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-print_rule"><a href="#val-print_rule" class="anchor"></a><code><span class="keyword">val</span> print_rule : Stdlib.out_channel <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> unit</code></dt></dl><aside><p>Here are the 3 type for tables used by out algorithm</p></aside><dl><dt class="spec module" id="module-K"><a href="#module-K" class="anchor"></a><code><span class="keyword">module</span> <a href="K/index.html">K</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This type is the state of the parsing table for the current position it only hold <code>'a final</code> elements whose <code>end</code> are the current position, the keys are the buffer uid's, column position and uid of the <code>full</code> and <code>rest</code> rules</p></dd></dl><div class="spec module" id="module-HK"><a href="#module-HK" class="anchor"></a><code><span class="keyword">module</span> <a href="HK/index.html">HK</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-cur"><a href="#type-cur" class="anchor"></a><code><span class="keyword">type</span> <span>'a cur</span></code><code> = <span><span><span class="type-var">'a</span> <a href="index.html#type-final">final</a></span> <a href="HK/index.html#type-t">HK.t</a></span></code></dt><dt class="spec type" id="type-reads"><a href="#type-reads" class="anchor"></a><code><span class="keyword">type</span> <span>'a reads</span></code><code> = <span><span><span><span class="type-var">'a</span> <a href="index.html#type-final">final</a></span> <a href="../Input/OrdTbl/index.html#type-t">Input.OrdTbl.t</a></span> Stdlib.ref</span></code></dt><dd><p>Type of a table with pending reading, that is elements resulting from reading the string with some symbols. We need this table, because two terminal symbols could read different length of the input from the same point</p></dd></dl><dl><dt class="spec type" id="type-sct"><a href="#type-sct" class="anchor"></a><code><span class="keyword">type</span> <span>'a sct</span></code><code> = <span><span class="type-var">'a</span> <a href="StackContainer/index.html#type-table">StackContainer.table</a></span></code></dt><dd><p>Stack construction. The type below, denotes table associate stack to rule. Recall we construct stack for elements whose <code>end</code> are the current position</p></dd></dl><dl><dt class="spec type" id="type-tmemo"><a href="#type-tmemo" class="anchor"></a><code><span class="keyword">type</span> tmemo</code><code> = <span>unit <a href="../Container/Ref/index.html#type-table">Container.Ref.table</a></span></code></dt><dd><p>Table to memoize the treatment of terminals and non terminals. This is important to garanty that results of actions are physicaly equals when they comes from the same parsing. To do this, terminals must read the input only once and the result must be memoized.</p></dd></dl><dl><dt class="spec value" id="val-add_stack_hook"><a href="#val-add_stack_hook" class="anchor"></a><code><span class="keyword">val</span> add_stack_hook : a b. <span><span class="type-var">'b</span> <a href="index.html#type-sct">sct</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> <span>(<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-element">element</a></span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_stack_hook sct rule fn</code> adds in <code>table</code> a hook <code>fn</code> for the given <code>rule</code>. <code>fn</code> will be called each time an element is added to the stack pointed by that <code>rule</code>. The hook is run on the existing elements if the stack. The stack is created if it did not exists yet</p></dd></dl><dl><dt class="spec value" id="val-add_stack"><a href="#val-add_stack" class="anchor"></a><code><span class="keyword">val</span> add_stack : a b. <span><span class="type-var">'b</span> <a href="index.html#type-sct">sct</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-element">element</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-stack">stack</a></span></code></dt><dd><p><code>add_stack sct rule element</code> add the given <code>element</code> to the stack of the given <code>rule</code> in the table <code>sct</code>. Runs all hooks if any. Creates the stack if needed</p></dd></dl><dl><dt class="spec value" id="val-find_stack"><a href="#val-find_stack" class="anchor"></a><code><span class="keyword">val</span> find_stack : a b. <span><span class="type-var">'b</span> <a href="index.html#type-sct">sct</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-stack">stack</a></span></code></dt><dd><p><code>find_stack sct rule</code> finds the stack to associate to the given rule, again the stack is created if needed</p></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val</span> size : <span><span class="type-var">'a</span> <a href="index.html#type-final">final</a></span> <span>&#45;&gt;</span> <span><span>(Stdlib.Obj.t, Stdlib.Obj.t)</span> <a href="index.html#type-stack">stack</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>Computes the size of an element stack, taking in account sharing</p></dd></dl><dl><dt class="spec value" id="val-size_tables"><a href="#val-size_tables" class="anchor"></a><code><span class="keyword">val</span> size_tables : <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'b</span> <a href="index.html#type-final">final</a></span>)</span> Stdlib.Hashtbl.t</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'c</span> <a href="index.html#type-final">final</a></span> <a href="../Input/OrdTbl/index.html#type-t">Input.OrdTbl.t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>Computes the size of the two tables, forward reading and the current elements. The other tables do not retain stack pointers</p></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val</span> size : <span><span class="type-var">'a</span> <a href="index.html#type-final">final</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>wrap up the size function</p></dd></dl><dl><dt class="spec value" id="val-tail_key"><a href="#val-tail_key" class="anchor"></a><code><span class="keyword">val</span> tail_key : a. <span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>A fonction to fetch the key of the tail of a rule, needed to get the key of an element representing a complete parsing</p></dd></dl><dl><dt class="spec value" id="val-final"><a href="#val-final" class="anchor"></a><code><span class="keyword">val</span> final : b c r. <a href="index.html#type-pos2">pos2</a> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-stack">stack</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'r</span> <a href="index.html#type-final">final</a></span></code></dt><dd><p>Constructor for the final type which includes its hash ley</p></dd></dl><dl><dt class="spec value" id="val-elt_key"><a href="#val-elt_key" class="anchor"></a><code><span class="keyword">val</span> elt_key : <span><span class="type-var">'a</span> <a href="index.html#type-final">final</a></span> <span>&#45;&gt;</span> int * int * int</code></dt><dd><p>Get the key of an element</p></dd></dl><dl><dt class="spec value" id="val-final_key"><a href="#val-final_key" class="anchor"></a><code><span class="keyword">val</span> final_key : <a href="index.html#type-pos2">pos2</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> int * int * int</code></dt><dd><p>Get the key of the final element when parsing is finished</p></dd></dl><dl><dt class="spec value" id="val-good"><a href="#val-good" class="anchor"></a><code><span class="keyword">val</span> good : char <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Test is a given char is accepted by the given rule</p></dd></dl><dl><dt class="spec value" id="val-max_stack"><a href="#val-max_stack" class="anchor"></a><code><span class="keyword">val</span> max_stack : <span>int Stdlib.ref</span></code></dt><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : string <span>&#45;&gt;</span> <a href="index.html#type-pos2">pos2</a> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-final">final</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-cur">cur</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Adds an element in the current table of elements, return true if new</p></dd></dl><aside><p>Combinators for actions, these are just the combinators we need, contructed from there types</p></aside><dl><dt class="spec value" id="val-cns"><a href="#val-cns" class="anchor"></a><code><span class="keyword">val</span> cns : a b c. <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p>This one for completion</p></dd></dl><dl><dt class="spec value" id="val-cns_pos"><a href="#val-cns_pos" class="anchor"></a><code><span class="keyword">val</span> cns_pos : a b c. <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="index.html#type-fpos">fpos</a></span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <a href="index.html#type-fpos">fpos</a></span></code></dt><dt class="spec value" id="val-cns_ign"><a href="#val-cns_ign" class="anchor"></a><code><span class="keyword">val</span> cns_ign : a b c. <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dt class="spec value" id="val-combine"><a href="#val-combine" class="anchor"></a><code><span class="keyword">val</span> combine : a c d. <span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <a href="index.html#type-pos">pos</a></span></code></dt><dd><p>This one for prediction</p></dd></dl><dl><dt class="spec value" id="val-combine_pos"><a href="#val-combine_pos" class="anchor"></a><code><span class="keyword">val</span> combine_pos : a c d. <span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <a href="index.html#type-fpos">fpos</a></span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <a href="index.html#type-pos">pos</a></span></code></dt><dt class="spec value" id="val-combine_ign"><a href="#val-combine_ign" class="anchor"></a><code><span class="keyword">val</span> combine_ign : a c d. <span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <a href="index.html#type-pos">pos</a></span></code></dt></dl><dl><dt class="spec exception" id="exception-Parse_error"><a href="#exception-Parse_error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Parse_error</span> <span class="keyword">of</span> <a href="../Input/index.html#type-buffer">Input.buffer</a> * int</code></dt><dd><p>Exception for parse error, can also be raise by Ter2 terminals, but no other terminal handles it</p></dd></dl><dl><dt class="spec value" id="val-update_errpos"><a href="#val-update_errpos" class="anchor"></a><code><span class="keyword">val</span> update_errpos : <span><span><span>(<a href="../Input/index.html#type-buffer">Input.buffer</a> * int)</span> option</span> Stdlib.ref</span> <span>&#45;&gt;</span> <a href="../Input/index.html#type-buffer">Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pred_prod_lec"><a href="#val-pred_prod_lec" class="anchor"></a><code><span class="keyword">val</span> pred_prod_lec : a. <a href="index.html#type-errpos">errpos</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-final">final</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-cur">cur</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-reads">reads</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-sct">sct</a></span> <span>&#45;&gt;</span> <a href="index.html#type-tmemo">tmemo</a> <span>&#45;&gt;</span> <a href="index.html#type-blank">blank</a> <span>&#45;&gt;</span> <a href="index.html#type-pos2">pos2</a> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p>This is now the main function computing all the consequences of the element given at first argument. It needs</p><ul><li>the element <code>elt0</code> being added</li><li>the <code>errpos</code> to record advaces in the parsing</li><li>the four tables: <code>elements forward sct tmemo</code></li><li>the <code>blank</code> (to pass it to Ter2 terminals)</li><li>the position <code>cur_pos</code> and current charater <code>c</code> for the action and the good test</li></ul><p>It performs prediction/completion/lecture in a recursive way.</p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : <span>int Stdlib.ref</span></code></dt><dt class="spec value" id="val-parse_buffer_aux"><a href="#val-parse_buffer_aux" class="anchor"></a><code><span class="keyword">val</span> parse_buffer_aux : a. <span>?&#8288;errpos:<a href="index.html#type-errpos">errpos</a></span> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <a href="index.html#type-blank">blank</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></span> <span>&#45;&gt;</span> <a href="../Input/index.html#type-buffer">Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> * <a href="../Input/index.html#type-buffer">Input.buffer</a> * int</code></dt><dd><p>The main parsing loop</p></dd></dl><dl><dt class="spec value" id="val-internal_parse_buffer"><a href="#val-internal_parse_buffer" class="anchor"></a><code><span class="keyword">val</span> internal_parse_buffer : a. <span>?&#8288;errpos:<a href="index.html#type-errpos">errpos</a></span> <span>&#45;&gt;</span> <span>?&#8288;blank_after:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-blank">blank</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></span> <span>&#45;&gt;</span> <a href="../Input/index.html#type-buffer">Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> * <a href="../Input/index.html#type-buffer">Input.buffer</a> * int</code></dt><dd><p>Function to call the parser in a terminal</p></dd></dl></div></body></html>