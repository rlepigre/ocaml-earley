<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Types (earley.Earley_core.Internals.Types)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">earley</a> &#x00BB; <a href="../../index.html">Earley_core</a> &#x00BB; <a href="../index.html">Internals</a> &#x00BB; Types</nav><h1>Module <code>Internals.Types</code></h1><p>A BNF grammar is a list of rules. The type parameter <code>'a</code> corresponds to the type of the semantics of the grammar. For example, parsing using a grammar of type <code>int grammar</code> will produce a value of type <code>int</code>.</p></header><dl><dt class="spec type" id="type-grammar"><a href="#type-grammar" class="anchor"></a><code><span class="keyword">type</span> <span>'a grammar</span></code><code> = <a href="../index.html#type-info">info</a> * <span><span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> list</span></code></dt><dd><p>The type of a grammar, with its information</p></dd></dl><dl><dt class="spec type" id="type-symbol"><a href="#type-symbol" class="anchor"></a><code><span class="keyword">and</span> <span>_ symbol</span></code><code> = </code><table class="variant"><tr id="type-symbol.Term" class="anchored"><td class="def constructor"><a href="#type-symbol.Term" class="anchor"></a><code>| </code><code><span class="constructor">Term</span> : </code><code>{</code><table class="record"><tr id="type-symbol.input" class="anchored"><td class="def field"><a href="#type-symbol.input" class="anchor"></a><code>input : <span><span class="type-var">'a</span> <a href="../index.html#type-input">input</a></span>;</code></td></tr><tr id="type-symbol.info" class="anchored"><td class="def field"><a href="#type-symbol.info" class="anchor"></a><code>info : <a href="../index.html#type-info">info</a>;</code></td></tr><tr id="type-symbol.memo" class="anchored"><td class="def field"><a href="#type-symbol.memo" class="anchor"></a><code>memo : <span><span class="type-var">'a</span> <a href="../index.html#type-tref">tref</a></span>;</code></td></tr><tr id="type-symbol.name" class="anchored"><td class="def field"><a href="#type-symbol.name" class="anchor"></a><code>name : string;</code></td></tr></table><code>}</code><code> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-symbol">symbol</a></span></code></td><td class="doc"><p>terminal symbol just read the input buffer</p></td></tr><tr id="type-symbol.Ter2" class="anchored"><td class="def constructor"><a href="#type-symbol.Ter2" class="anchor"></a><code>| </code><code><span class="constructor">Ter2</span> : </code><code>{</code><table class="record"><tr id="type-symbol.input" class="anchored"><td class="def field"><a href="#type-symbol.input" class="anchor"></a><code>input : <span><span class="type-var">'a</span> <a href="../index.html#type-input2">input2</a></span>;</code></td></tr><tr id="type-symbol.info" class="anchored"><td class="def field"><a href="#type-symbol.info" class="anchor"></a><code>info : <a href="../index.html#type-info">info</a>;</code></td></tr><tr id="type-symbol.memo" class="anchored"><td class="def field"><a href="#type-symbol.memo" class="anchor"></a><code>memo : <span><span class="type-var">'a</span> <a href="../index.html#type-tref">tref</a></span>;</code></td></tr><tr id="type-symbol.name" class="anchored"><td class="def field"><a href="#type-symbol.name" class="anchor"></a><code>name : string;</code></td></tr></table><code>}</code><code> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-symbol">symbol</a></span></code></td><td class="doc"><p>Ter2 correspond to a recursive call to the parser. We can change the blank function for instance, or parse input as much as possible. In fact it is only in the combinators in earley.ml that we see the use Ter2 to call the parser back.</p></td></tr><tr id="type-symbol.Test" class="anchored"><td class="def constructor"><a href="#type-symbol.Test" class="anchor"></a><code>| </code><code><span class="constructor">Test</span> : </code><code>{</code><table class="record"><tr id="type-symbol.input" class="anchored"><td class="def field"><a href="#type-symbol.input" class="anchor"></a><code>input : <span><span class="type-var">'a</span> <a href="../index.html#type-test">test</a></span>;</code></td></tr><tr id="type-symbol.info" class="anchored"><td class="def field"><a href="#type-symbol.info" class="anchor"></a><code>info : <a href="../index.html#type-info">info</a>;</code></td></tr><tr id="type-symbol.memo" class="anchored"><td class="def field"><a href="#type-symbol.memo" class="anchor"></a><code>memo : <span><span class="type-var">'a</span> <a href="../index.html#type-tref">tref</a></span>;</code></td></tr><tr id="type-symbol.name" class="anchored"><td class="def field"><a href="#type-symbol.name" class="anchor"></a><code>name : string;</code></td></tr></table><code>}</code><code> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-symbol">symbol</a></span></code></td><td class="doc"><p>Test on the input, can for instance read blanks, usefull for things like ocamldoc (but not yet used by earley-ocaml).</p></td></tr><tr id="type-symbol.NonTerm" class="anchored"><td class="def constructor"><a href="#type-symbol.NonTerm" class="anchor"></a><code>| </code><code><span class="constructor">NonTerm</span> : </code><code>{</code><table class="record"><tr id="type-symbol.rules" class="anchored"><td class="def field"><a href="#type-symbol.rules" class="anchor"></a><code><span class="keyword">mutable</span> rules : <span><span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> list</span>;</code></td></tr><tr id="type-symbol.info" class="anchored"><td class="def field"><a href="#type-symbol.info" class="anchor"></a><code><span class="keyword">mutable</span> info : <a href="../index.html#type-info">info</a>;</code></td></tr><tr id="type-symbol.memo" class="anchored"><td class="def field"><a href="#type-symbol.memo" class="anchor"></a><code>memo : <span><span class="type-var">'a</span> <a href="index.html#type-ntref">ntref</a></span>;</code></td></tr><tr id="type-symbol.name" class="anchored"><td class="def field"><a href="#type-symbol.name" class="anchor"></a><code>name : string;</code></td></tr></table><code>}</code><code> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-symbol">symbol</a></span></code></td><td class="doc"><p>Non terminals trough a mutable field to define recursive rule lists</p></td></tr></table></dt><dd><p>The symbol, a more general concept that terminals</p></dd></dl><dl><dt class="spec type" id="type-ntref"><a href="#type-ntref" class="anchor"></a><code><span class="keyword">and</span> <span>'a ntref</span></code><code> = <span><span><span><span class="type-var">'a</span> <a href="index.html#type-rule">rule</a></span> list</span> <a href="../index.html#type-cref">cref</a></span></code></dt><dd><p>Type of a container ref to memoize treatment of non terminal</p></dd></dl><dl><dt class="spec type" id="type-prerule"><a href="#type-prerule" class="anchor"></a><code><span class="keyword">and</span> <span>_ prerule</span></code><code> = </code><table class="variant"><tr id="type-prerule.Empty" class="anchored"><td class="def constructor"><a href="#type-prerule.Empty" class="anchor"></a><code>| </code><code><span class="constructor">Empty</span> : <span><span class="type-var">'a</span> <a href="../index.html#type-pos">pos</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-prerule">prerule</a></span></code></td><td class="doc"><p>Empty rule.</p></td></tr><tr id="type-prerule.Next" class="anchored"><td class="def constructor"><a href="#type-prerule.Next" class="anchor"></a><code>| </code><code><span class="constructor">Next</span> : <a href="../index.html#type-info">info</a> * <span><span class="type-var">'a</span> <a href="index.html#type-symbol">symbol</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-next">next</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-prerule">prerule</a></span></code></td><td class="doc"><p>Sequence of a symbol and a rule, with a possible name for debugging, the information on the rule, the symbol to read, an action and the rest of the rule</p></td></tr><tr id="type-prerule.Dep" class="anchored"><td class="def constructor"><a href="#type-prerule.Dep" class="anchor"></a><code>| </code><code><span class="constructor">Dep</span> : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-rule">rule</a></span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="index.html#type-prerule">prerule</a></span></code></td><td class="doc"><p>Dependant rule, gives a lot of power! but costly! use only when no other solution is possible</p></td></tr></table></dt><dd><p>BNF rule.</p></dd></dl><dl><dt class="spec type" id="type-next"><a href="#type-next" class="anchor"></a><code><span class="keyword">and</span> <span>('a, 'c) next</span></code><code> = </code><table class="variant"><tr id="type-next.Arg" class="anchored"><td class="def constructor"><a href="#type-next.Arg" class="anchor"></a><code>| </code><code><span class="constructor">Arg</span> : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-next">next</a></span></code></td></tr><tr id="type-next.Pos" class="anchored"><td class="def constructor"><a href="#type-next.Pos" class="anchor"></a><code>| </code><code><span class="constructor">Pos</span> : <span><span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <a href="../index.html#type-fpos">fpos</a></span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-next">next</a></span></code></td></tr><tr id="type-next.Ign" class="anchored"><td class="def constructor"><a href="#type-next.Ign" class="anchor"></a><code>| </code><code><span class="constructor">Ign</span> : <span><span class="type-var">'c</span> <a href="index.html#type-rule">rule</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-next">next</a></span></code></td></tr></table></dt><dt class="spec type" id="type-rule"><a href="#type-rule" class="anchor"></a><code><span class="keyword">and</span> <span>'a rule</span></code><code> = </code><code>{</code><table class="record"><tr id="type-rule.rule" class="anchored"><td class="def field"><a href="#type-rule.rule" class="anchor"></a><code>rule : <span><span class="type-var">'a</span> <a href="index.html#type-prerule">prerule</a></span>;</code></td></tr><tr id="type-rule.ptr" class="anchored"><td class="def field"><a href="#type-rule.ptr" class="anchor"></a><code>ptr : <span><span class="type-var">'a</span> <a href="../StackContainer/index.html#type-container">StackContainer.container</a></span>;</code></td></tr><tr id="type-rule.adr" class="anchored"><td class="def field"><a href="#type-rule.adr" class="anchor"></a><code>adr : int;</code></td></tr></table><code>}</code></dt><dd><p>Each rule holds a container to associate data to the rule in O(1). see below the description of the type ('a,'b) pre_stack</p></dd></dl><dl><dt class="spec type" id="type-final"><a href="#type-final" class="anchor"></a><code><span class="keyword">type</span> <span>_ final</span></code><code> = </code><table class="variant"><tr id="type-final.D" class="anchored"><td class="def constructor"><a href="#type-final.D" class="anchor"></a><code>| </code><code><span class="constructor">D</span> : </code><code>{</code><table class="record"><tr id="type-final.start" class="anchored"><td class="def field"><a href="#type-final.start" class="anchor"></a><code>start : <a href="../index.html#type-pos2">pos2</a>;</code></td><td class="doc"><p>position in buffer, before and after blank</p></td></tr><tr id="type-final.stack" class="anchored"><td class="def field"><a href="#type-final.stack" class="anchor"></a><code>stack : <span><span>(<span class="type-var">'c</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-stack">stack</a></span>;</code></td><td class="doc"><p>tree of stack representing what should be done after reading the <code>rest</code> of the rule</p></td></tr><tr id="type-final.acts" class="anchored"><td class="def field"><a href="#type-final.acts" class="anchor"></a><code>acts : <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>;</code></td><td class="doc"><p>action to produce the final 'c.</p></td></tr><tr id="type-final.rest" class="anchored"><td class="def field"><a href="#type-final.rest" class="anchor"></a><code>rest : <span><span class="type-var">'b</span> <a href="index.html#type-rule">rule</a></span>;</code></td><td class="doc"><p>remaining to parse, will produce 'b</p></td></tr><tr id="type-final.full" class="anchored"><td class="def field"><a href="#type-final.full" class="anchor"></a><code>full : <span><span class="type-var">'c</span> <a href="index.html#type-rule">rule</a></span>;</code></td><td class="doc"><p>full rule. rest is a suffix of full.</p></td></tr></table><code>}</code><code> <span>&#45;&gt;</span> <span><span class="type-var">'r</span> <a href="index.html#type-final">final</a></span></code></td></tr></table></dt><dd><p>Type of an active element of the earley table. In a description of earley, each table element is <code>(start, end, done * rest)</code> meaning we parsed the string from <code>start</code> to <code>end</code> with the rule <code>done</code> and it remains to parse <code>rest</code>. The <code>*</code> therefore denotes the current position. Earley is basically a dynamic algorithm producing all possible elements.</p><p>We depart from this representation in two ways:</p><ul><li>we do not represent <code>done</code>, we keep the whole whole rule: <code>full = done rest</code></li></ul><ul><li>we never keep <code>end</code>. It is only used when we finish parsing of a rule and we have an element <code>(start, end, done * Empty)</code> then, we look for other elements of the form <code>(start', end', done' * rest')</code> where <code>end' = start</code>, <code>rest' = nonterm' rest''</code> and <code>nonterm'</code> is a non terminal containing the <code>done</code> rule. We represent this situation by a stack in the element <code>(start, end, done * Empty)</code>, which is maintained to lists all the elements satisfying the above property (no more, no less, each element only once)</li></ul><p>The type <code>'a final</code> represent an element of the earley table where <code>end</code> is the current position in the string being parsed.</p></dd></dl><dl><dt class="spec type" id="type-element"><a href="#type-element" class="anchor"></a><code><span class="keyword">and</span> <span>(_, _) element</span></code><code> = </code><table class="variant"><tr id="type-element.B" class="anchored"><td class="def constructor"><a href="#type-element.B" class="anchor"></a><code>| </code><code><span class="constructor">B</span> : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <a href="../index.html#type-pos">pos</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-element">element</a></span></code></td><td class="doc"><p>End of the stack, with an action to produce the final parser value</p></td></tr><tr id="type-element.C" class="anchored"><td class="def constructor"><a href="#type-element.C" class="anchor"></a><code>| </code><code><span class="constructor">C</span> : </code><code>{</code><table class="record"><tr id="type-element.start" class="anchored"><td class="def field"><a href="#type-element.start" class="anchor"></a><code>start : <a href="../index.html#type-pos2">pos2</a>;</code></td></tr><tr id="type-element.stack" class="anchored"><td class="def field"><a href="#type-element.stack" class="anchor"></a><code>stack : <span><span>(<span class="type-var">'c</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-stack">stack</a></span>;</code></td></tr><tr id="type-element.acts" class="anchored"><td class="def field"><a href="#type-element.acts" class="anchor"></a><code>acts : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <a href="../index.html#type-pos">pos</a></span>;</code></td><td class="doc"><p>Here we wait <code>x:'a</code> from parents</p></td></tr><tr id="type-element.rest" class="anchored"><td class="def field"><a href="#type-element.rest" class="anchor"></a><code>rest : <span><span class="type-var">'b</span> <a href="index.html#type-rule">rule</a></span>;</code></td></tr><tr id="type-element.full" class="anchored"><td class="def field"><a href="#type-element.full" class="anchor"></a><code>full : <span><span class="type-var">'c</span> <a href="index.html#type-rule">rule</a></span>;</code></td></tr></table><code>}</code><code> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-element">element</a></span></code></td><td class="doc"><p>Cons cell of the stack with a record similar to D's</p></td></tr></table></dt><dd><p>Type of the element that appears in stacks. Note: all other elements no reachable from stacks will be collected by the GC, which is what we want to release memory.</p><p>The type is similar to the previous: <code>('a, 'r) element</code>, means that from a value of type 'a, comming from our parent in the stack, we could produce a value of type <code>'r</code> using <code>rest</code>.</p><p>The action needs to be prametrised by the future position which is unknown.</p></dd></dl><dl><dt class="spec type" id="type-stack"><a href="#type-stack" class="anchor"></a><code><span class="keyword">and</span> <span>('a, 'b) stack</span></code><code> = <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-element">element</a></span> list</span> Stdlib.ref</span></code></dt><dd><p>Stack themselves are an acyclic graph of elements (sharing is important to be preserved). We need a reference for the stack construction.</p></dd></dl><aside><p>For the construction of the stack, all elements of the same list ref of type ('a,'b) stack have the same en position <code>end'</code>. And all elements that points to this stack have their begin position <code>start = end'</code>. Moreover, all elements with the same <code>full</code> and <code>start</code> must point to the same stack. Recall that <code>end</code> is not represented in elements.</p><p>We call the position <code>end'</code> associated to a stack (as said the <code>start</code> of the element that point to this stack, the &quot;stack position&quot;. An important point: new stack elements are constructed when the stack position is the current position.</p><p>Moreover, when we add a point from an element <code>(start, end, rest, full)</code> to a stack (which is therefore at position <code>start</code>, we have <code>start = end</code> and <code>rest = full</code>. The rule has not parsed anything! This is the &quot;prediction&quot; phase of earley.</p><p>To do this construction, we use the record below with a hook that we run on all elements added to that stack. This record is only used with stack whose position are the current position: all these records will become inaccessible when we advance in parsing.</p><p>Morevoer, a direct pointer (thanks to the Container module) is kept from the <code>full</code> rule of all elements that point to these stack and that have the current position as <code>end</code>. This is the role of the functor call below.</p></aside><dl><dt class="spec type" id="type-pre_stack"><a href="#type-pre_stack" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) pre_stack</span></code><code> = </code><code>{</code><table class="record"><tr id="type-pre_stack.stack" class="anchored"><td class="def field"><a href="#type-pre_stack.stack" class="anchor"></a><code>stack : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-stack">stack</a></span>;</code></td></tr><tr id="type-pre_stack.hooks" class="anchored"><td class="def field"><a href="#type-pre_stack.hooks" class="anchor"></a><code><span class="keyword">mutable</span> hooks : <span><span>(<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-element">element</a></span> <span>&#45;&gt;</span> unit)</span> list</span>;</code></td></tr></table><code>}</code></dt><dd><p>stack in construction ... they have a hook, to run on elements added to the stack later !</p></dd></dl></div></body></html>